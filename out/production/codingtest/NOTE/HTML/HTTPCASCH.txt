캐시
캐시가 없을떄
->똑같은 요청을 보낼떄 바디를 계속 다시만들고 데이터를 다운로드 받아야 하므로 로딩 속도가 느리고
비용이 많이든다

캐시적용
캐시적용 시간을 지정한다음 응답 결과를 캐시에 저장한 다음 캐시에 저장된 정보를 가져와서 쓴다
캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
ex)들어갔던 사이트에 다시 들어가면 로딩 속도가 빠르다

캐시 시간 초과
저장해 두었던 캐시를 사용
단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요

검증 헤더 추가

1. 요청을 보낼떄 (Last-Modified : 데이터가 마지막 수정된 시간) 헤더추가
2. 캐시 시간이 끝난후 다시 요청을 보낼떄
 (if-modified-since : 시간 -> 시간이 일치하는 캐시 사용가능)보냄
3. 304 Not Modifed 상태코드를 보냄(변화가 없다), HTTP Body가 없음(캐시 재사용)
단점->
1초 미만 단위로 캐시 조정이 불가능, 주석처럼 크게 영향이 없는 변경에서도 캐시를 유지하고 싶은 경우

ETag, If-None-Match
캐시용 데이터에 임의의 고유한 버전 이름을 달아둠, 데이터가 변경되면 이름을 바꾸어서 전송
단순하게 ETage만 보내서 같으면 유지, 다르만 다시 받기
캐시 제어 로직을 서버에서 완전히 관리

캐시 제어 헤더
Casch-Control
max-age : 캐시 유효 기간, 초 단위
no-cache : 캐시해도 되나, 항상 원 서버에 검증하고 사용
no-store : 민감한 정보가 있으므로 저장하면 안됨(최대한 빨리 삭제)

Pragma(HTTP 1.0 하위 호환)
Expires(하위 호환, 캐시 만료일 지정할수있음, max-age권장)

프록시 캐시
미국서버로 바로 가지 않고 한국에 있는 프록시 캐시 서버를 거쳐서 미국에 있는 원 서버로 감

캐시 무효화
캐시를 적용 안해도 GET요청인 경우 임의의로 캐시를 지정해버림
Cache-Control : no-cache, no-store, must-revalidate
Pragma : no-cache(HTTP 1.0)

must-revalidate : 프록시 캐시와 원 서버의 네트워크가 단절되었을때 에러 표시보다는 예전 데이터라도 보여준다(200 OK)
이러한 상황에 무조건 504코드를 보낸다